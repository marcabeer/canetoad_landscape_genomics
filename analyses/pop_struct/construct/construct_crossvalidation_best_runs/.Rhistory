#path to crossvalidation outputs
cv_path <- "~/analyses/pop_struct/construct/construct_crossvalidation_best_runs"
my.xvals <- readRDS(paste(cv_path,"my.xvals"), sep="/")
my.xvals <- readRDS(paste(cv_path,"my.xvals", sep="/"))
getwd()
#path to crossvalidation outputs
cv_subdir <- "construct_crossvalidation_best_runs"
my.xvals <- readRDS(paste(getwd(), cv_subdir,"my.xvals", sep="/"))
sp.results <- Reduce("cbind",lapply(my.xvals,function(x){unlist(x$sp)}),init=NULL)
nsp.results <- Reduce("cbind",lapply(my.xvals,function(x){unlist(x$nsp)}),init=NULL)
sp.CIs <- apply(sp.results,1,function(x){mean(x) + c(-1.96,1.96) * sd(x)/length(x)})
nsp.CIs <- apply(nsp.results,1,function(x){mean(x) + c(-1.96,1.96) * sd(x)/length(x)})
# then, plot cross-validation results for K=1:3 with 8 replicates
par(mfrow=c(2,1))
plot(rowMeans(sp.results),
pch=19,col="blue", cex=1.5,
ylab="predictive accuracy",xlab="values of K",
ylim=range(sp.results,nsp.results),
main="cross-validation results")
points(rowMeans(nsp.results),col="green",pch=19, cex=1.5,)
plot(rowMeans(sp.results),
pch=19,col="blue",
ylab="predictive accuracy",xlab="values of K",
ylim=range(sp.CIs),
main="spatial cross-validation results", cex=1.5,)
segments(x0 = 1:nrow(sp.results),
y0 = sp.CIs[1,],
x1 = 1:nrow(sp.results),
y1 = sp.CIs[2,],
col = "blue",lwd=2)
#find best spatial model replicate for each value of K to compare layer contributions
best_rep <- data.frame(K=1:10, rep=NA)
for (i in 1:nrow(sp.results)){
best_rep[i,2] <- which.max(sp.results[i,])
}
###
#compare layer contributions
layer.contributions <- matrix(NA,nrow=10,ncol=10)
##############################
#Compare layer contributions
##############################
layer.contributions <- matrix(NA,nrow=10,ncol=10)
load("cv_sp_rep1K1_conStruct.results.Robj")
load(paste(paste(getwd(), cv_subdir,"cv_sp_rep1K1_conStruct.results.Robj", sep="/"))
load(paste(getwd(), cv_subdir,"cv_sp_rep1K1_conStruct.results.Robj", sep="/"))
paste(getwd(), cv_subdir,"cv_sp_rep1K1_conStruct.results.Robj", sep="/")
load(paste(getwd(), cv_subdir,"cv_sp_rep1K1_conStruct.results.Robj", sep="/"))
load(paste(getwd(), cv_subdir,"cv_sp_rep1K1_data.block.Robj", sep="/"))
rep_path <- paste(getwd(), cv_subdir, sep="/")
for(i in 2:10){
# load the conStruct.results.Robj and data.block.Robj
#   files saved at the end of a conStruct run
load(paste(rep_path, "/cv_sp_rep", best_rep[i,2], "K", best_rep[i,1], "_conStruct.results.Robj",  sep=""))
load(paste(rep_path, "/cv_sp_rep", best_rep[i,2], "K", best_rep[i,1], "_data.block.Robj",  sep=""))
# match layers up across runs to keep plotting colors consistent
#   for the same layers in different runs
tmp.order <- match.layers.x.runs(tmp,conStruct.results[[1]]$MAP$admix.proportions)
# calculate layer contributions
layer.contributions[,i] <- c(calculate.layer.contribution(conStruct.results=conStruct.results[[1]],
data.block=data.block,
layer.order=tmp.order),
rep(0,10-i))
tmp <- conStruct.results[[1]]$MAP$admix.proportions[,tmp.order]
}
library(conStruct)
##############################
#Compare layer contributions
##############################
layer.contributions <- matrix(NA,nrow=10,ncol=10)
rep_path <- paste(getwd(), cv_subdir, sep="/")
load(paste(getwd(), cv_subdir,"cv_sp_rep1K1_conStruct.results.Robj", sep="/"))
load(paste(getwd(), cv_subdir,"cv_sp_rep1K1_data.block.Robj", sep="/"))
tmp <- conStruct.results[[1]]$MAP$admix.proportions
layer.contributions[,1] <- c(calculate.layer.contribution(conStruct.results[[1]],data.block),rep(0,9))
for(i in 2:10){
# load the conStruct.results.Robj and data.block.Robj
#   files saved at the end of a conStruct run
load(paste(rep_path, "/cv_sp_rep", best_rep[i,2], "K", best_rep[i,1], "_conStruct.results.Robj",  sep=""))
load(paste(rep_path, "/cv_sp_rep", best_rep[i,2], "K", best_rep[i,1], "_data.block.Robj",  sep=""))
# match layers up across runs to keep plotting colors consistent
#   for the same layers in different runs
tmp.order <- match.layers.x.runs(tmp,conStruct.results[[1]]$MAP$admix.proportions)
# calculate layer contributions
layer.contributions[,i] <- c(calculate.layer.contribution(conStruct.results=conStruct.results[[1]],
data.block=data.block,
layer.order=tmp.order),
rep(0,10-i))
tmp <- conStruct.results[[1]]$MAP$admix.proportions[,tmp.order]
}
par(mfrow=c(1,1))
barplot(layer.contributions,
xlab="",
ylab="layer contributions",
names.arg=paste0("K=",1:10))
unique(layer.contributions[,4])
View(layer.contributions)
###
#make STRUCTURE plots
md <- read.table(paste(getwd(),"env_filtered", sep="/"), header=TRUE, sep="\t")
# then, plot cross-validation results for K=1:10 with 20 replicates
par(mfrow=c(2,1))
plot(rowMeans(sp.results),
pch=19,col="blue", cex=1.5,
ylab="predictive accuracy",xlab="values of K",
ylim=range(sp.results,nsp.results),
main="cross-validation results")
points(rowMeans(nsp.results),col="green",pch=19, cex=1.5,)
# finally, visualize results for the spatial model
#   separately with its confidence interval bars
#
# note that you could do the same with the spatial model,
#   but the confidence intervals don't really show up
#   because the differences between predictive accuracies
#   across values of K are so large.
plot(rowMeans(sp.results),
pch=19,col="blue",
ylab="predictive accuracy",xlab="values of K",
ylim=range(sp.CIs),
main="spatial cross-validation results", cex=1.5,)
segments(x0 = 1:nrow(sp.results),
y0 = sp.CIs[1,],
x1 = 1:nrow(sp.results),
y1 = sp.CIs[2,],
col = "blue",lwd=2)
k3_best_results <- load(paste(rep_path, "/cv_sp_rep15K3_conStruct.results.Robj", sep="/"))
k3_best_data <- load(paste(rep_path, "cv_sp_rep15K3_data.block.Robj", sep="/"))
#load in best K=3 crossvalidation run
load(paste(rep_path, "/cv_sp_rep15K3_conStruct.results.Robj", sep="/"))
load(paste(rep_path, "cv_sp_rep15K3_data.block.Robj", sep="/"))
# assign model results to new variable names
k3sp_cr <- conStruct.results
k3sp_db <- data.block
#get admixture/ancestry proportions
admix.props_k3 <- k3sp_cr$chain_1$MAP$admix.proportions
# assign model results to new variable names
k4sp_cr <- conStruct.results
k4sp_db <- data.block
#get admixture/ancestry proportions
admix.props_k4 <- k4sp_cr$chain_1$MAP$admix.proportions
###
#load in best K=4 crossvalidation run
load("cv_sp_rep7K4_conStruct.results.Robj")
###
#load in best K=4 crossvalidation run
load(paste(rep_path, "cv_sp_rep7K4_conStruct.results.Robj", sep="/"))
load(paste(rep_path, "cv_sp_rep7K4_data.block.Robj", sep="/"))
# assign model results to new variable names
k4sp_cr <- conStruct.results
k4sp_db <- data.block
#get admixture/ancestry proportions
admix.props_k4 <- k4sp_cr$chain_1$MAP$admix.proportions
###
#load in best K=5 crossvalidation run
load(paste(rep_path, "cv_sp_rep19K5_conStruct.results.Robj", sep="/"))
load(paste(rep_path, "cv_sp_rep19K5_data.block.Robj", sep="/"))
# assign model results to new variable names
k5sp_cr <- conStruct.results
k5sp_db <- data.block
admix.props_k5 <- k5sp_cr$chain_1$MAP$admix.proportions
###
#make plots
par(mfrow=c(2,3))
make.structure.plot(admix.proportions = admix.props_k3, sample.order=order(md$long))
make.structure.plot(admix.proportions = admix.props_k4, sample.order=order(md$long))
make.structure.plot(admix.proportions = admix.props_k5, sample.order=order(md$long))
make.admix.pie.plot(admix.proportions = admix.props_k3, coords = data.block$coords)
make.admix.pie.plot(admix.proportions = admix.props_k4, coords = data.block$coords)
make.admix.pie.plot(admix.proportions = admix.props_k5, coords = data.block$coords)
par(mfrow=c(3,2))
make.structure.plot(admix.proportions = admix.props_k3, sample.order=order(md$long))
make.admix.pie.plot(admix.proportions = admix.props_k3, coords = data.block$coords, radii=2)
make.structure.plot(admix.proportions = admix.props_k4, sample.order=order(md$long))
make.admix.pie.plot(admix.proportions = admix.props_k4, coords = data.block$coords, radii=2)
make.structure.plot(admix.proportions = admix.props_k5, sample.order=order(md$long))
make.admix.pie.plot(admix.proportions = admix.props_k5, coords = data.block$coords, radii=2)
wd_base <- "~/analyses/pop_struct/construct"
#########
#load packages
library(conStruct)
library(dplyr)
library(tidyr)
library(plotrix)
library(ggplot2)
library(patchwork)
library(rnaturalearth)
library(rnaturalearthdata)
library(rnaturalearthhires)
library(sf)
##########
###
#read in metadata
md <- read.table(paste(wd_base, "/env_filtered", sep=""), sep="\t", header=TRUE)
wd_base <- "~/analyses/pop_struct/construct"
##########
###
#read in metadata
md <- read.table(paste(wd_base, "/env_filtered", sep=""), sep="\t", header=TRUE)
##########
###
#read in metadata
md <- read.table(paste(getwd(), "/env_filtered", sep=""), sep="\t", header=TRUE)
setwd(paste(getwd(), "/construct_crossvalidation_best_runs", sep=""))
#read in cross-validation R object
my.xvals <- readRDS("my.xvals")
#isolate results for spatial (sp) and non-spatial (nsp) models
sp.results <- Reduce("cbind",lapply(my.xvals,function(x){unlist(x$sp)}),init=NULL)
nsp.results <- Reduce("cbind",lapply(my.xvals,function(x){unlist(x$nsp)}),init=NULL)
#find best spatial model replicate for each value of K to compare layer contributions
best_rep <- data.frame(K=1:10, rep=NA)
for (i in 1:nrow(sp.results)){
best_rep[i,2] <- which.max(sp.results[i,])
}
###
#compare layer contributions
layer.contributions <- matrix(NA,nrow=10,ncol=10)
load("cv_sp_rep1K1_conStruct.results.Robj")
load("cv_sp_rep1K1_data.block.Robj")
tmp <- conStruct.results[[1]]$MAP$admix.proportions
layer.contributions[,1] <- c(calculate.layer.contribution(conStruct.results[[1]],data.block),rep(0,9))
for(i in 2:10){
# load the conStruct.results.Robj and data.block.Robj
#   files saved at the end of a conStruct run
load(paste("cv_sp_rep", best_rep[i,2], "K", best_rep[i,1], "_conStruct.results.Robj",  sep=""))
load(paste("cv_sp_rep", best_rep[i,2], "K", best_rep[i,1], "_data.block.Robj",  sep=""))
# match layers up across runs to keep plotting colors consistent
#   for the same layers in different runs
tmp.order <- match.layers.x.runs(tmp,conStruct.results[[1]]$MAP$admix.proportions)
# calculate layer contributions
layer.contributions[,i] <- c(calculate.layer.contribution(conStruct.results=conStruct.results[[1]],
data.block=data.block,
layer.order=tmp.order),
rep(0,10-i))
tmp <- conStruct.results[[1]]$MAP$admix.proportions[,tmp.order]
}
###
#set some plotting parameters
plot_marg <- 20
###
#cross-validation model accuracy plots
cv_accuracy_long <- data.frame(k=rep(rep(1:10, 20),2), model=rep(c("spatial", "non-spatial"), each=20*10), accuracy=c(c(sp.results), c(nsp.results)))
cv_accuracy_summ <- cv_accuracy_long %>%
group_by(k, model) %>%
summarise(acc_mean = mean(accuracy), acc_95ci = 1.96*std.error(accuracy))
clrblind_pal <- c("#000000", "#D81B60")
#predictive accuracy for all values of K
p_acc <- ggplot()+
geom_errorbar(data=cv_accuracy_summ, mapping=aes(ymin=acc_mean - acc_95ci, ymax=acc_mean + acc_95ci, x=as.factor(k), width=0.2))+
geom_point(data=cv_accuracy_summ, mapping=aes(y=acc_mean, x=as.factor(k), fill=model), shape=21, colour="black", size=3)+
scale_colour_manual(values=clrblind_pal)+
scale_fill_manual(values=clrblind_pal)+
theme_bw()+
labs(x="K (No. geogenetic layers)", y="Predictive accuracy", fill="Model", colour="Model")+
theme(axis.title.x = element_text(size=18, margin = margin(t = 10, r = 0, b = 0, l = 0)),
axis.title.y = element_text(size=18, margin = margin(t = 0, r = 10, b = 0, l = 0)))+
theme(axis.text.x = element_text(size=14), axis.text.y = element_text(size=14))+
theme(legend.title = element_text(size=16), legend.text = element_text(size=14))+
theme(legend.position = c(0.8,0.2))+
theme(plot.margin = margin(t = plot_marg, r = plot_marg, b = plot_marg, l = plot_marg))
#predictive accuracy for K >= 2
p_acc_zoom <- ggplot()+
geom_errorbar(data=cv_accuracy_summ[-which(cv_accuracy_summ$k==1),], mapping=aes(ymin=acc_mean - acc_95ci, ymax=acc_mean + acc_95ci, x=as.factor(k), width=0.2))+
geom_point(data=cv_accuracy_summ[-which(cv_accuracy_summ$k==1),], mapping=aes(y=acc_mean, x=as.factor(k), fill=model), shape=21, colour="black", size=3.5)+
scale_colour_manual(values=clrblind_pal)+
scale_fill_manual(values=clrblind_pal)+
theme_bw()+
labs(x="K (No. geogenetic layers)", y="Predictive accuracy", fill="Model", colour="Model")+
theme(axis.title.x = element_text(size=18, margin = margin(t = 10, r = 0, b = 0, l = 0)),
axis.title.y = element_text(size=18, margin = margin(t = 0, r = 10, b = 0, l = 0)))+
theme(axis.text.x = element_text(size=14), axis.text.y = element_text(size=14))+
theme(legend.title = element_text(size=16), legend.text = element_text(size=14))+
theme(legend.position = c(0.8,0.2))+
theme(plot.margin = margin(t = plot_marg, r = plot_marg, b = plot_marg, l = plot_marg))
#combine plots
(p_acc | p_acc_zoom) + plot_annotation(tag_levels="A") & theme(plot.tag = element_text(size = 25))
##########
###
#cross-validation layer contribution plot
pal = c("deepskyblue4", "goldenrod1", "orangered", "darkviolet", "antiquewhite", "gray60", "chocolate1", "cadetblue1", "firebrick4", "deeppink")
lyrs <- data.frame(k=rep(1:10,10), layer=rep(1:10, each=10), contribution=c(t(layer.contributions)))
#stackplot
p_lyr_contribs <- ggplot(lyrs, aes(fill=as.factor(layer), y=contribution, x=k)) +
geom_bar(position="stack", stat="identity", width=1, colour="black", linewidth=0.75)+
scale_fill_manual(values=pal)+
labs(x = "K (No. geogenetic layers)", y="Layer contribution", fill="Layer")+
scale_y_continuous(limits=c(0,1), breaks=seq(from=0, to=1, by=0.2), expand=c(0,0))+
scale_x_discrete(limits=factor(1:10), expand=c(0,0))+
theme_bw()+
theme(axis.title.x = element_text(size=18, margin = margin(t = 10, r = 0, b = 0, l = 0)),
axis.title.y = element_text(size=18, margin = margin(t = 0, r = 10, b = 0, l = 0)))+
theme(axis.text.x = element_text(size=14), axis.text.y = element_text(size=14))+
theme(legend.title = element_text(size=16), legend.text = element_text(size=14))+
theme(plot.margin = margin(t = plot_marg, r = plot_marg, b = plot_marg, l = plot_marg))
p_lyr_contribs
#minimum non-zero layer contribution
lyrs_min <- data.frame(k=1:10, min_contrib=NA)
for (i in 1:10){
tmp_contrib <- lyrs$contribution[which(lyrs$k==i)]
tmp_contrib[tmp_contrib==0] <- NA
lyrs_min$min_contrib[i] <- min(tmp_contrib, na.rm=TRUE)
}
p_lyrs_min <- ggplot()+
geom_hline(yintercept=0, size=1, colour="gray70")+
geom_line(lyrs_min, mapping=aes(x=k, y=min_contrib), colour="black", linewidth=1)+
geom_point(lyrs_min, mapping=aes(x=k, y=min_contrib), colour="black", size=3)+
geom_hline(yintercept=0.05, linetype=2, size=1, colour="red")+ ###line indicates 5% layer contribution
scale_y_continuous(limits=c(0,1), breaks=seq(from=0, to=1, by=0.2))+
scale_x_continuous(limits=c(1,10), breaks=seq(from=1, to=10, by=1))+
labs(x="K (No. geogenetic layers)", y="Minimum layer contribution")+
theme_bw()+
theme(axis.title.x = element_text(size=18, margin = margin(t = 10, r = 0, b = 0, l = 0)),
axis.title.y = element_text(size=18, margin = margin(t = 0, r = 10, b = 0, l = 0)))+
theme(axis.text.x = element_text(size=14), axis.text.y = element_text(size=14))+
theme(legend.title = element_text(size=16), legend.text = element_text(size=14))+
theme(plot.margin = margin(t = plot_marg, r = plot_marg, b = plot_marg, l = plot_marg))
#combine plots
cv_layout <- "
AAABBB
AAABBB
CCCDDD
CCCDDD
"
p_acc + p_acc_zoom + p_lyr_contribs + p_lyrs_min + plot_layout(design=cv_layout) + plot_annotation(tag_levels="A") & theme(plot.tag = element_text(size = 25))
